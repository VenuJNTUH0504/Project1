<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Asynchronous Programming</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.js"></script>
    <style>
        :root {
            --primary-bg: #f0f2f5;
            --text-color: #2c3e50;
            --card-bg: #ffffff;
            --hover-color: linear-gradient(145deg, #4ECDC4, #6BE5D9);
            --hover-shadow: rgba(78, 205, 196, 0.3);
            --code-bg: #f8f9fa;
            --code-border: #e9ecef;
        }

        .dark-theme {
            --primary-bg: #1a1a1a;
            --text-color: #ffffff;
            --card-bg: #2d2d2d;
            --hover-color: linear-gradient(145deg, #00B894, #00CEC9);
            --hover-shadow: rgba(0, 184, 148, 0.3);
            --code-bg: #2a2a2a;
            --code-border: #3a3a3a;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            transition: all 0.3s ease;
            line-height: 1.6;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--card-bg);
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            position: relative;
            display: inline-block;
        }

        h1::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--hover-color);
            border-radius: 2px;
        }

        h2 {
            font-size: 1.8rem;
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--code-border);
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.4rem;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        p {
            margin-bottom: 20px;
        }

        .code-block {
            background-color: var(--code-bg);
            border: 1px solid var(--code-border);
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: monospace;
        }

        .example-section {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--code-bg);
            border-radius: 10px;
        }

        .example-title {
            font-weight: bold;
            margin-bottom: 10px;
        }

        .theme-switch {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            background: var(--card-bg);
            border: none;
            color: var(--text-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .theme-switch:hover {
            background-image: var(--hover-color);
            color: white;
            transform: scale(1.05);
        }

        .back-button {
            display: inline-block;
            margin-bottom: 20px;
            padding: 10px 20px;
            background-color: var(--card-bg);
            color: var(--text-color);
            text-decoration: none;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background-image: var(--hover-color);
            color: white;
            transform: translateX(-5px);
        }

        .note {
            background-color: rgba(255, 243, 205, 0.3);
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning {
            background-color: rgba(248, 215, 218, 0.3);
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .tip {
            background-color: rgba(209, 231, 221, 0.3);
            border-left: 4px solid #198754;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--code-border);
        }

        th {
            background-color: var(--code-bg);
        }

        .editor-container {
            margin: 20px 0;
        }

        .CodeMirror {
            height: auto;
            border-radius: 5px;
        }

        .demo-container {
            border: 2px solid var(--code-border);
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
            background-color: var(--card-bg);
        }

        .demo-result {
            margin-top: 15px;
            padding: 15px;
            background-color: var(--code-bg);
            border-radius: 5px;
            min-height: 50px;
        }

        .button-container {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .demo-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            background-color: #4ECDC4;
            color: white;
        }

        .demo-button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        .progress-container {
            width: 100%;
            height: 20px;
            background-color: var(--code-bg);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0;
            background-color: #4ECDC4;
            transition: width 0.3s ease;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .comparison-table th, .comparison-table td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--code-border);
        }

        .comparison-table th {
            background-color: var(--code-bg);
        }

        .comparison-table tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.02);
        }
    </style>
</head>
<body>
    <button class="theme-switch" onclick="toggleTheme()">Toggle Theme</button>
    <div class="container">
        <a href="javascript.html" class="back-button">‚Üê Back to JavaScript Home</a>
        
        <div class="header">
            <h1>JavaScript Asynchronous Programming</h1>
        </div>

        <section>
            <h2>What is Asynchronous Programming?</h2>
            <p>Asynchronous programming is a programming paradigm that allows operations to execute independently of the main program flow. In JavaScript, asynchronous programming is essential for handling operations that might take some time to complete, such as:</p>
            <ul>
                <li>Fetching data from a server</li>
                <li>Reading files</li>
                <li>Executing complex calculations</li>
                <li>Waiting for user input</li>
            </ul>
            
            <div class="note">
                <strong>Note:</strong> JavaScript is single-threaded, which means it can only execute one piece of code at a time. Asynchronous programming allows JavaScript to perform non-blocking operations, making it possible to handle multiple operations concurrently without freezing the user interface.
            </div>
        </section>

        <section>
            <h2>Synchronous vs. Asynchronous Code</h2>
            
            <h3>Synchronous Code</h3>
            <p>In synchronous programming, operations are executed one after another. Each operation must complete before the next one begins.</p>
            
            <div class="code-block">
                <pre>console.log("First");
console.log("Second");
console.log("Third");

// Output:
// First
// Second
// Third</pre>
            </div>
            
            <h3>Asynchronous Code</h3>
            <p>In asynchronous programming, operations can be executed independently of the main program flow. This allows the program to continue executing while waiting for an asynchronous operation to complete.</p>
            
            <div class="code-block">
                <pre>console.log("First");

setTimeout(() => {
    console.log("Second (after 2 seconds)");
}, 2000);

console.log("Third");

// Output:
// First
// Third
// Second (after 2 seconds)</pre>
            </div>
            
            <div class="tip">
                <strong>Key Insight:</strong> In the asynchronous example, "Third" is logged before "Second" because <code>setTimeout</code> is an asynchronous function that doesn't block the execution of the code that follows it.
            </div>
        </section>

        <section>
            <h2>Callback Functions</h2>
            <p>Callbacks are functions passed as arguments to other functions, which are then invoked when an asynchronous operation completes.</p>
            
            <div class="code-block">
                <pre>function fetchData(callback) {
    // Simulate an API call with setTimeout
    setTimeout(() => {
        const data = { name: "John", age: 30 };
        callback(data);
    }, 2000);
}

console.log("Fetching data...");

fetchData((data) => {
    console.log("Data received:", data);
});

console.log("Continuing with other tasks...");

// Output:
// Fetching data...
// Continuing with other tasks...
// Data received: { name: "John", age: 30 } (after 2 seconds)</pre>
            </div>
            
            <h3>Callback Hell</h3>
            <p>One of the challenges with callbacks is that they can lead to deeply nested code, often referred to as "callback hell" or the "pyramid of doom."</p>
            
            <div class="code-block">
                <pre>fetchUserData((userData) => {
    fetchUserPosts(userData.id, (posts) => {
        fetchPostComments(posts[0].id, (comments) => {
            fetchCommentAuthor(comments[0].authorId, (author) => {
                console.log("Author of the first comment:", author);
                // More nested callbacks...
            });
        });
    });
});</pre>
            </div>
            
            <div class="warning">
                <strong>Problem:</strong> Callback hell makes code harder to read, debug, and maintain. It also makes error handling more complex.
            </div>
        </section>

        <section>
            <h2>Promises</h2>
            <p>Promises provide a cleaner way to handle asynchronous operations. A Promise represents a value that might not be available yet but will be resolved at some point in the future.</p>
            
            <h3>Promise States</h3>
            <ul>
                <li><strong>Pending:</strong> Initial state, neither fulfilled nor rejected.</li>
                <li><strong>Fulfilled:</strong> The operation completed successfully.</li>
                <li><strong>Rejected:</strong> The operation failed.</li>
            </ul>
            
            <h3>Creating a Promise</h3>
            <div class="code-block">
                <pre>const myPromise = new Promise((resolve, reject) => {
    // Asynchronous operation
    setTimeout(() => {
        const success = true;
        
        if (success) {
            resolve("Operation completed successfully!");
        } else {
            reject("Operation failed!");
        }
    }, 2000);
});</pre>
            </div>
            
            <h3>Using Promises</h3>
            <div class="code-block">
                <pre>myPromise
    .then((result) => {
        console.log("Success:", result);
    })
    .catch((error) => {
        console.error("Error:", error);
    })
    .finally(() => {
        console.log("Promise settled (fulfilled or rejected)");
    });

// Output (if successful):
// Success: Operation completed successfully!
// Promise settled (fulfilled or rejected)</pre>
            </div>
            
            <h3>Chaining Promises</h3>
            <p>One of the key advantages of Promises is the ability to chain them, which helps avoid callback hell.</p>
            
            <div class="code-block">
                <pre>fetchUserData()
    .then(userData => {
        return fetchUserPosts(userData.id);
    })
    .then(posts => {
        return fetchPostComments(posts[0].id);
    })
    .then(comments => {
        return fetchCommentAuthor(comments[0].authorId);
    })
    .then(author => {
        console.log("Author of the first comment:", author);
    })
    .catch(error => {
        console.error("Error in the promise chain:", error);
    });</pre>
            </div>
            
            <h3>Promise.all()</h3>
            <p><code>Promise.all()</code> takes an array of promises and returns a new promise that fulfills when all the promises in the array have fulfilled, or rejects if any of the promises reject.</p>
            
            <div class="code-block">
                <pre>const promise1 = fetchUserData();
const promise2 = fetchUserPosts();
const promise3 = fetchUserComments();

Promise.all([promise1, promise2, promise3])
    .then(([userData, posts, comments]) => {
        console.log("All data fetched:", userData, posts, comments);
    })
    .catch(error => {
        console.error("At least one promise failed:", error);
    });</pre>
            </div>
            
            <h3>Promise.race()</h3>
            <p><code>Promise.race()</code> takes an array of promises and returns a new promise that fulfills or rejects as soon as one of the promises in the array fulfills or rejects.</p>
            
            <div class="code-block">
                <pre>const promise1 = new Promise(resolve => setTimeout(() => resolve("Promise 1"), 2000));
const promise2 = new Promise(resolve => setTimeout(() => resolve("Promise 2"), 1000));

Promise.race([promise1, promise2])
    .then(result => {
        console.log("Fastest promise result:", result); // "Promise 2"
    });</pre>
            </div>
        </section>

        <section>
            <h2>Async/Await</h2>
            <p>Async/await is a syntactic sugar built on top of Promises, making asynchronous code look and behave more like synchronous code.</p>
            
            <h3>Async Functions</h3>
            <p>An async function is a function declared with the <code>async</code> keyword. Async functions always return a Promise.</p>
            
            <div class="code-block">
                <pre>async function fetchData() {
    return "Data fetched!";
}

// Equivalent to:
function fetchData() {
    return Promise.resolve("Data fetched!");
}</pre>
            </div>
            
            <h3>Await Operator</h3>
            <p>The <code>await</code> operator is used to wait for a Promise to settle (either fulfill or reject). It can only be used inside an async function.</p>
            
            <div class="code-block">
                <pre>async function fetchUserData() {
    try {
        const response = await fetch('https://api.example.com/users/1');
        const userData = await response.json();
        console.log("User data:", userData);
        return userData;
    } catch (error) {
        console.error("Error fetching user data:", error);
        throw error;
    }
}</pre>
            </div>
            
            <h3>Rewriting Promise Chains with Async/Await</h3>
            <p>Async/await makes it easier to write and understand complex asynchronous code.</p>
            
            <div class="code-block">
                <pre>// Using Promise chains
function fetchUserDataWithPromises() {
    return fetchUserData()
        .then(userData => {
            return fetchUserPosts(userData.id);
        })
        .then(posts => {
            return fetchPostComments(posts[0].id);
        })
        .then(comments => {
            return fetchCommentAuthor(comments[0].authorId);
        });
}

// Using async/await
async function fetchUserDataWithAsyncAwait() {
    try {
        const userData = await fetchUserData();
        const posts = await fetchUserPosts(userData.id);
        const comments = await fetchPostComments(posts[0].id);
        const author = await fetchCommentAuthor(comments[0].authorId);
        return author;
    } catch (error) {
        console.error("Error:", error);
        throw error;
    }
}</pre>
            </div>
            
            <h3>Parallel Execution with Async/Await</h3>
            <p>You can combine <code>Promise.all()</code> with async/await for parallel execution.</p>
            
            <div class="code-block">
                <pre>async function fetchAllData() {
    try {
        const [userData, posts, comments] = await Promise.all([
            fetchUserData(),
            fetchUserPosts(),
            fetchUserComments()
        ]);
        
        console.log("All data fetched:", userData, posts, comments);
        return { userData, posts, comments };
    } catch (error) {
        console.error("Error fetching data:", error);
        throw error;
    }
}</pre>
            </div>
        </section>

        <section>
            <h2>Fetch API</h2>
            <p>The Fetch API provides a modern interface for making HTTP requests. It returns Promises, making it easy to use with async/await.</p>
            
            <div class="code-block">
                <pre>// Basic GET request
fetch('https://api.example.com/data')
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        console.log('Data:', data);
    })
    .catch(error => {
        console.error('Fetch error:', error);
    });

// Using async/await
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        
        const data = await response.json();
        console.log('Data:', data);
        return data;
    } catch (error) {
        console.error('Fetch error:', error);
        throw error;
    }
}</pre>
            </div>
            
            <h3>POST Request with Fetch</h3>
            <div class="code-block">
                <pre>async function postData(url, data) {
    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        
        return await response.json();
    } catch (error) {
        console.error('Fetch error:', error);
        throw error;
    }
}

// Usage
postData('https://api.example.com/users', { name: 'John', age: 30 })
    .then(data => console.log('Success:', data))
    .catch(error => console.error('Error:', error));</pre>
            </div>
        </section>

        <section>
            <h2>Error Handling in Asynchronous Code</h2>
            
            <h3>With Promises</h3>
            <div class="code-block">
                <pre>fetchData()
    .then(data => {
        // Handle success
        console.log('Data:', data);
    })
    .catch(error => {
        // Handle any errors in the promise chain
        console.error('Error:', error);
    })
    .finally(() => {
        // Code that runs regardless of success or failure
        console.log('Fetch operation completed');
    });</pre>
            </div>
            
            <h3>With Async/Await</h3>
            <div class="code-block">
                <pre>async function fetchDataWithErrorHandling() {
    try {
        const data = await fetchData();
        console.log('Data:', data);
    } catch (error) {
        console.error('Error:', error);
    } finally {
        console.log('Fetch operation completed');
    }
}</pre>
            </div>
        </section>

        <section>
            <h2>Comparison of Asynchronous Patterns</h2>
            
            <table class="comparison-table">
                <tr>
                    <th>Pattern</th>
                    <th>Pros</th>
                    <th>Cons</th>
                    <th>Best Used For</th>
                </tr>
                <tr>
                    <td>Callbacks</td>
                    <td>
                        <ul>
                            <li>Simple to understand</li>
                            <li>Widely supported</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Can lead to callback hell</li>
                            <li>Error handling is complex</li>
                            <li>No built-in flow control</li>
                        </ul>
                    </td>
                    <td>Simple, one-off asynchronous operations</td>
                </tr>
                <tr>
                    <td>Promises</td>
                    <td>
                        <ul>
                            <li>Chainable</li>
                            <li>Better error handling</li>
                            <li>Supports composition (Promise.all, Promise.race)</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>More complex than callbacks</li>
                            <li>Still requires chaining for sequential operations</li>
                        </ul>
                    </td>
                    <td>Multiple asynchronous operations with dependencies</td>
                </tr>
                <tr>
                    <td>Async/Await</td>
                    <td>
                        <ul>
                            <li>Looks like synchronous code</li>
                            <li>Easier to read and debug</li>
                            <li>Try/catch for error handling</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Requires understanding of Promises</li>
                            <li>Needs special handling for parallel operations</li>
                            <li>Not supported in older browsers without transpilation</li>
                        </ul>
                    </td>
                    <td>Complex asynchronous workflows, especially with sequential operations</td>
                </tr>
            </table>
        </section>

        <section>
            <h2>Interactive Examples</h2>
            
            <h3>Example 1: Callbacks vs. Promises vs. Async/Await</h3>
            <div class="demo-container">
                <div id="demo1">
                    <h4>Asynchronous Patterns Comparison</h4>
                    <p>This example demonstrates the same task implemented using different asynchronous patterns.</p>
                    
                    <div class="button-container">
                        <button id="btn-callback" class="demo-button">Run with Callbacks</button>
                        <button id="btn-promise" class="demo-button">Run with Promises</button>
                        <button id="btn-async" class="demo-button">Run with Async/Await</button>
                    </div>
                    
                    <div id="demo1-result" class="demo-result">Results will appear here...</div>
                </div>
                
                <div class="editor-container">
                    <textarea id="editor1">
// Simulated asynchronous operations
function simulateApiCall(data, delay) {
    return new Promise((resolve) => {
        setTimeout(() => resolve(data), delay);
    });
}

// Using Callbacks
function fetchDataWithCallbacks(callback) {
    console.log("Fetching user with callbacks...");
    
    setTimeout(() => {
        const user = { id: 1, name: "John" };
        console.log("User fetched with callbacks:", user);
        
        setTimeout(() => {
            const posts = [
                { id: 101, title: "Post 1" },
                { id: 102, title: "Post 2" }
            ];
            console.log("Posts fetched with callbacks:", posts);
            
            setTimeout(() => {
                const comments = [
                    { id: 201, text: "Great post!" },
                    { id: 202, text: "I learned a lot." }
                ];
                console.log("Comments fetched with callbacks:", comments);
                
                callback({
                    user: user,
                    posts: posts,
                    comments: comments
                });
            }, 1000); // Fetch comments
        }, 1000); // Fetch posts
    }, 1000); // Fetch user
}

// Using Promises
function fetchDataWithPromises() {
    console.log("Fetching user with promises...");
    
    return simulateApiCall({ id: 1, name: "John" }, 1000)
        .then(user => {
            console.log("User fetched with promises:", user);
            return simulateApiCall([
                { id: 101, title: "Post 1" },
                { id: 102, title: "Post 2" }
            ], 1000).then(posts => {
                return { user, posts };
            });
        })
        .then(data => {
            console.log("Posts fetched with promises:", data.posts);
            return simulateApiCall([
                { id: 201, text: "Great post!" },
                { id: 202, text: "I learned a lot." }
            ], 1000).then(comments => {
                console.log("Comments fetched with promises:", comments);
                return {
                    user: data.user,
                    posts: data.posts,
                    comments: comments
                };
            });
        });
}

// Using Async/Await
async function fetchDataWithAsyncAwait() {
    console.log("Fetching user with async/await...");
    
    const user = await simulateApiCall({ id: 1, name: "John" }, 1000);
    console.log("User fetched with async/await:", user);
    
    const posts = await simulateApiCall([
        { id: 101, title: "Post 1" },
        { id: 102, title: "Post 2" }
    ], 1000);
    console.log("Posts fetched with async/await:", posts);
    
    const comments = await simulateApiCall([
        { id: 201, text: "Great post!" },
        { id: 202, text: "I learned a lot." }
    ], 1000);
    console.log("Comments fetched with async/await:", comments);
    
    return {
        user: user,
        posts: posts,
        comments: comments
    };
}

// Event handlers for buttons
document.getElementById('btn-callback').addEventListener('click', function() {
    const resultDiv = document.getElementById('demo1-result');
    resultDiv.innerHTML = 'Running with callbacks...';
    
    fetchDataWithCallbacks(result => {
        resultDiv.innerHTML = `
            <h4>Result with Callbacks:</h4>
            <pre>${JSON.stringify(result, null, 2)}</pre>
            <p>Check the console for detailed logs.</p>
        `;
    });
});

document.getElementById('btn-promise').addEventListener('click', function() {
    const resultDiv = document.getElementById('demo1-result');
    resultDiv.innerHTML = 'Running with promises...';
    
    fetchDataWithPromises()
        .then(result => {
            resultDiv.innerHTML = `
                <h4>Result with Promises:</h4>
                <pre>${JSON.stringify(result, null, 2)}</pre>
                <p>Check the console for detailed logs.</p>
            `;
        });
});

document.getElementById('btn-async').addEventListener('click', async function() {
    const resultDiv = document.getElementById('demo1-result');
    resultDiv.innerHTML = 'Running with async/await...';
    
    const result = await fetchDataWithAsyncAwait();
    resultDiv.innerHTML = `
        <h4>Result with Async/Await:</h4>
        <pre>${JSON.stringify(result, null, 2)}</pre>
        <p>Check the console for detailed logs.</p>
    `;
});
</textarea>
                </div>
            </div>
            
            <h3>Example 2: Promise Methods</h3>
            <div class="demo-container">
                <div id="demo2">
                    <h4>Promise Methods Demo</h4>
                    <p>This example demonstrates different Promise methods for handling multiple asynchronous operations.</p>
                    
                    <div class="button-container">
                        <button id="btn-promise-all" class="demo-button">Promise.all</button>
                        <button id="btn-promise-race" class="demo-button">Promise.race</button>
                        <button id="btn-promise-allsettled" class="demo-button">Promise.allSettled</button>
                        <button id="btn-promise-any" class="demo-button">Promise.any</button>
                    </div>
                    
                    <div id="demo2-result" class="demo-result">Results will appear here...</div>
                </div>
                
                <div class="editor-container">
                    <textarea id="editor2">
// Create promises with different delays and outcomes
function createPromise(id, delay, shouldResolve) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (shouldResolve) {
                resolve(`Promise ${id} resolved after ${delay}ms`);
            } else {
                reject(`Promise ${id} rejected after ${delay}ms`);
            }
        }, delay);
    });
}

// Promise.all
document.getElementById('btn-promise-all').addEventListener('click', function() {
    const resultDiv = document.getElementById('demo2-result');
    resultDiv.innerHTML = 'Running Promise.all...';
    
    const promises = [
        createPromise(1, 1000, true),
        createPromise(2, 2000, true),
        createPromise(3, 1500, true)
    ];
    
    Promise.all(promises)
        .then(results => {
            resultDiv.innerHTML = `
                <h4>Promise.all Result:</h4>
                <p>All promises resolved successfully!</p>
                <pre>${JSON.stringify(results, null, 2)}</pre>
                <p>Promise.all waits for all promises to resolve. If any promise rejects, the entire operation rejects.</p>
            `;
        })
        .catch(error => {
            resultDiv.innerHTML = `
                <h4>Promise.all Error:</h4>
                <p>${error}</p>
                <p>Promise.all fails fast if any promise rejects.</p>
            `;
        });
});

// Promise.race
document.getElementById('btn-promise-race').addEventListener('click', function() {
    const resultDiv = document.getElementById('demo2-result');
    resultDiv.innerHTML = 'Running Promise.race...';
    
    const promises = [
        createPromise(1, 3000, true),
        createPromise(2, 1000, true),
        createPromise(3, 2000, true)
    ];
    
    Promise.race(promises)
        .then(result => {
            resultDiv.innerHTML = `
                <h4>Promise.race Result:</h4>
                <p>${result}</p>
                <p>Promise.race returns the result of the first promise that settles (either resolves or rejects).</p>
            `;
        })
        .catch(error => {
            resultDiv.innerHTML = `
                <h4>Promise.race Error:</h4>
                <p>${error}</p>
            `;
        });
});

// Promise.allSettled
document.getElementById('btn-promise-allsettled').addEventListener('click', function() {
    const resultDiv = document.getElementById('demo2-result');
    resultDiv.innerHTML = 'Running Promise.allSettled...';
    
    const promises = [
        createPromise(1, 1000, true),
        createPromise(2, 2000, false),
        createPromise(3, 1500, true)
    ];
    
    Promise.allSettled(promises)
        .then(results => {
            resultDiv.innerHTML = `
                <h4>Promise.allSettled Result:</h4>
                <pre>${JSON.stringify(results, null, 2)}</pre>
                <p>Promise.allSettled waits for all promises to settle (either resolve or reject) and returns an array of their results.</p>
            `;
        });
});

// Promise.any
document.getElementById('btn-promise-any').addEventListener('click', function() {
    const resultDiv = document.getElementById('demo2-result');
    resultDiv.innerHTML = 'Running Promise.any...';
    
    const promises = [
        createPromise(1, 3000, true),
        createPromise(2, 1000, false),
        createPromise(3, 2000, true)
    ];
    
    // Check if Promise.any is supported
    if (typeof Promise.any === 'function') {
        Promise.any(promises)
            .then(result => {
                resultDiv.innerHTML = `
                    <h4>Promise.any Result:</h4>
                    <p>${result}</p>
                    <p>Promise.any returns the first promise that fulfills (resolves). If all promises reject, it throws an AggregateError.</p>
                `;
            })
            .catch(error => {
                resultDiv.innerHTML = `
                    <h4>Promise.any Error:</h4>
                    <p>All promises rejected</p>
                    <pre>${error.message}</pre>
                `;
            });
    } else {
        resultDiv.innerHTML = `
            <h4>Promise.any Not Supported</h4>
            <p>Your browser does not support Promise.any. This method is relatively new and may not be available in all browsers.</p>
        `;
    }
});
</textarea>
                </div>
            </div>
            
            <h3>Example 3: Fetch API with Async/Await</h3>
            <div class="demo-container">
                <div id="demo3">
                    <h4>Fetch API Demo</h4>
                    <p>This example demonstrates using the Fetch API with async/await to retrieve data from a public API.</p>
                    
                    <div class="button-container">
                        <button id="btn-fetch-users" class="demo-button">Fetch Users</button>
                        <button id="btn-fetch-posts" class="demo-button">Fetch Posts</button>
                        <button id="btn-fetch-both" class="demo-button">Fetch Both (Parallel)</button>
                    </div>
                    
                    <div class="progress-container">
                        <div id="fetch-progress" class="progress-bar"></div>
                    </div>
                    
                    <div id="demo3-result" class="demo-result">Results will appear here...</div>
                </div>
                
                <div class="editor-container">
                    <textarea id="editor3">
// Helper function to update progress bar
function updateProgress(percent) {
    const progressBar = document.getElementById('fetch-progress');
    progressBar.style.width = `${percent}%`;
}

// Fetch users
async function fetchUsers() {
    const resultDiv = document.getElementById('demo3-result');
    resultDiv.innerHTML = 'Fetching users...';
    updateProgress(20);
    
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users');
        updateProgress(60);
        
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const users = await response.json();
        updateProgress(100);
        
        return users;
    } catch (error) {
        updateProgress(100);
        throw error;
    }
}

// Fetch posts
async function fetchPosts() {
    const resultDiv = document.getElementById('demo3-result');
    resultDiv.innerHTML = 'Fetching posts...';
    updateProgress(20);
    
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        updateProgress(60);
        
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const posts = await response.json();
        updateProgress(100);
        
        return posts;
    } catch (error) {
        updateProgress(100);
        throw error;
    }
}

// Event handlers for buttons
document.getElementById('btn-fetch-users').addEventListener('click', async function() {
    const resultDiv = document.getElementById('demo3-result');
    updateProgress(0);
    
    try {
        const users = await fetchUsers();
        
        resultDiv.innerHTML = `
            <h4>Users:</h4>
            <p>Fetched ${users.length} users</p>
            <pre>${JSON.stringify(users.slice(0, 3), null, 2)}...</pre>
        `;
    } catch (error) {
        resultDiv.innerHTML = `
            <h4>Error:</h4>
            <p>${error.message}</p>
        `;
    }
});

document.getElementById('btn-fetch-posts').addEventListener('click', async function() {
    const resultDiv = document.getElementById('demo3-result');
    updateProgress(0);
    
    try {
        const posts = await fetchPosts();
        
        resultDiv.innerHTML = `
            <h4>Posts:</h4>
            <p>Fetched ${posts.length} posts</p>
            <pre>${JSON.stringify(posts.slice(0, 3), null, 2)}...</pre>
        `;
    } catch (error) {
        resultDiv.innerHTML = `
            <h4>Error:</h4>
            <p>${error.message}</p>
        `;
    }
});

document.getElementById('btn-fetch-both').addEventListener('click', async function() {
    const resultDiv = document.getElementById('demo3-result');
    resultDiv.innerHTML = 'Fetching users and posts in parallel...';
    updateProgress(0);
    
    try {
        // Start both fetch operations in parallel
        const usersPromise = fetch('https://jsonplaceholder.typicode.com/users');
        const postsPromise = fetch('https://jsonplaceholder.typicode.com/posts');
        
        updateProgress(30);
        
        // Wait for both to complete
        const [usersResponse, postsResponse] = await Promise.all([usersPromise, postsPromise]);
        
        updateProgress(60);
        
        // Check if responses are ok
        if (!usersResponse.ok || !postsResponse.ok) {
            throw new Error('One or more requests failed');
        }
        
        // Parse JSON from both responses
        const users = await usersResponse.json();
        const posts = await postsResponse.json();
        
        updateProgress(100);
        
        resultDiv.innerHTML = `
            <h4>Parallel Fetch Results:</h4>
            <p>Fetched ${users.length} users and ${posts.length} posts</p>
            <h5>Users (first 2):</h5>
            <pre>${JSON.stringify(users.slice(0, 2), null, 2)}</pre>
            <h5>Posts (first 2):</h5>
            <pre>${JSON.stringify(posts.slice(0, 2), null, 2)}</pre>
            <p>Using Promise.all allows multiple fetch operations to run in parallel, saving time.</p>
        `;
    } catch (error) {
        updateProgress(100);
        resultDiv.innerHTML = `
            <h4>Error:</h4>
            <p>${error.message}</p>
        `;
    }
});

// Initialize
updateProgress(0);
</textarea>
                </div>
            </div>
        </section>
    </div>

    <script>
        function toggleTheme() {
            document.body.classList.toggle('dark-theme');
        }

        // Initialize CodeMirror editors
        let editor1 = CodeMirror.fromTextArea(document.getElementById("editor1"), {
            mode: "javascript",
            theme: "dracula",
            lineNumbers: true,
            readOnly: true
        });

        let editor2 = CodeMirror.fromTextArea(document.getElementById("editor2"), {
            mode: "javascript",
            theme: "dracula",
            lineNumbers: true,
            readOnly: true
        });

        let editor3 = CodeMirror.fromTextArea(document.getElementById("editor3"), {
            mode: "javascript",
            theme: "dracula",
            lineNumbers: true,
            readOnly: true
        });

        // Simulated asynchronous operations
        function simulateApiCall(data, delay) {
            return new Promise((resolve) => {
                setTimeout(() => resolve(data), delay);
            });
        }

        // Using Callbacks
        function fetchDataWithCallbacks(callback) {
            console.log("Fetching user with callbacks...");
            
            setTimeout(() => {
                const user = { id: 1, name: "John" };
                console.log("User fetched with callbacks:", user);
                
                setTimeout(() => {
                    const posts = [
                        { id: 101, title: "Post 1" },
                        { id: 102, title: "Post 2" }
                    ];
                    console.log("Posts fetched with callbacks:", posts);
                    
                    setTimeout(() => {
                        const comments = [
                            { id: 201, text: "Great post!" },
                            { id: 202, text: "I learned a lot." }
                        ];
                        console.log("Comments fetched with callbacks:", comments);
                        
                        callback({
                            user: user,
                            posts: posts,
                            comments: comments
                        });
                    }, 1000); // Fetch comments
                }, 1000); // Fetch posts
            }, 1000); // Fetch user
        }

        // Using Promises
        function fetchDataWithPromises() {
            console.log("Fetching user with promises...");
            
            return simulateApiCall({ id: 1, name: "John" }, 1000)
                .then(user => {
                    console.log("User fetched with promises:", user);
                    return simulateApiCall([
                        { id: 101, title: "Post 1" },
                        { id: 102, title: "Post 2" }
                    ], 1000).then(posts => {
                        return { user, posts };
                    });
                })
                .then(data => {
                    console.log("Posts fetched with promises:", data.posts);
                    return simulateApiCall([
                        { id: 201, text: "Great post!" },
                        { id: 202, text: "I learned a lot." }
                    ], 1000).then(comments => {
                        console.log("Comments fetched with promises:", comments);
                        return {
                            user: data.user,
                            posts: data.posts,
                            comments: comments
                        };
                    });
                });
        }

        // Using Async/Await
        async function fetchDataWithAsyncAwait() {
            console.log("Fetching user with async/await...");
            
            const user = await simulateApiCall({ id: 1, name: "John" }, 1000);
            console.log("User fetched with async/await:", user);
            
            const posts = await simulateApiCall([
                { id: 101, title: "Post 1" },
                { id: 102, title: "Post 2" }
            ], 1000);
            console.log("Posts fetched with async/await:", posts);
            
            const comments = await simulateApiCall([
                { id: 201, text: "Great post!" },
                { id: 202, text: "I learned a lot." }
            ], 1000);
            console.log("Comments fetched with async/await:", comments);
            
            return {
                user: user,
                posts: posts,
                comments: comments
            };
        }

        // Event handlers for buttons in Example 1
        document.getElementById('btn-callback').addEventListener('click', function() {
            const resultDiv = document.getElementById('demo1-result');
            resultDiv.innerHTML = 'Running with callbacks...';
            
            fetchDataWithCallbacks(result => {
                resultDiv.innerHTML = `
                    <h4>Result with Callbacks:</h4>
                    <pre>${JSON.stringify(result, null, 2)}</pre>
                    <p>Check the console for detailed logs.</p>
                `;
            });
        });

        document.getElementById('btn-promise').addEventListener('click', function() {
            const resultDiv = document.getElementById('demo1-result');
            resultDiv.innerHTML = 'Running with promises...';
            
            fetchDataWithPromises()
                .then(result => {
                    resultDiv.innerHTML = `
                        <h4>Result with Promises:</h4>
                        <pre>${JSON.stringify(result, null, 2)}</pre>
                        <p>Check the console for detailed logs.</p>
                    `;
                });
        });

        document.getElementById('btn-async').addEventListener('click', async function() {
            const resultDiv = document.getElementById('demo1-result');
            resultDiv.innerHTML = 'Running with async/await...';
            
            const result = await fetchDataWithAsyncAwait();
            resultDiv.innerHTML = `
                <h4>Result with Async/Await:</h4>
                <pre>${JSON.stringify(result, null, 2)}</pre>
                <p>Check the console for detailed logs.</p>
            `;
        });

        // Create promises with different delays and outcomes for Example 2
        function createPromise(id, delay, shouldResolve) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (shouldResolve) {
                        resolve(`Promise ${id} resolved after ${delay}ms`);
                    } else {
                        reject(`Promise ${id} rejected after ${delay}ms`);
                    }
                }, delay);
            });
        }

        // Promise.all
        document.getElementById('btn-promise-all').addEventListener('click', function() {
            const resultDiv = document.getElementById('demo2-result');
            resultDiv.innerHTML = 'Running Promise.all...';
            
            const promises = [
                createPromise(1, 1000, true),
                createPromise(2, 2000, true),
                createPromise(3, 1500, true)
            ];
            
            Promise.all(promises)
                .then(results => {
                    resultDiv.innerHTML = `
                        <h4>Promise.all Result:</h4>
                        <p>All promises resolved successfully!</p>
                        <pre>${JSON.stringify(results, null, 2)}</pre>
                        <p>Promise.all waits for all promises to resolve. If any promise rejects, the entire operation rejects.</p>
                    `;
                })
                .catch(error => {
                    resultDiv.innerHTML = `
                        <h4>Promise.all Error:</h4>
                        <p>${error}</p>
                        <p>Promise.all fails fast if any promise rejects.</p>
                    `;
                });
        });

        // Promise.race
        document.getElementById('btn-promise-race').addEventListener('click', function() {
            const resultDiv = document.getElementById('demo2-result');
            resultDiv.innerHTML = 'Running Promise.race...';
            
            const promises = [
                createPromise(1, 3000, true),
                createPromise(2, 1000, true),
                createPromise(3, 2000, true)
            ];
            
            Promise.race(promises)
                .then(result => {
                    resultDiv.innerHTML = `
                        <h4>Promise.race Result:</h4>
                        <p>${result}</p>
                        <p>Promise.race returns the result of the first promise that settles (either resolves or rejects).</p>
                    `;
                })
                .catch(error => {
                    resultDiv.innerHTML = `
                        <h4>Promise.race Error:</h4>
                        <p>${error}</p>
                    `;
                });
        });

        // Promise.allSettled
        document.getElementById('btn-promise-allsettled').addEventListener('click', function() {
            const resultDiv = document.getElementById('demo2-result');
            resultDiv.innerHTML = 'Running Promise.allSettled...';
            
            const promises = [
                createPromise(1, 1000, true),
                createPromise(2, 2000, false),
                createPromise(3, 1500, true)
            ];
            
            Promise.allSettled(promises)
                .then(results => {
                    resultDiv.innerHTML = `
                        <h4>Promise.allSettled Result:</h4>
                        <pre>${JSON.stringify(results, null, 2)}</pre>
                        <p>Promise.allSettled waits for all promises to settle (either resolve or reject) and returns an array of their results.</p>
                    `;
                });
        });

        // Promise.any
        document.getElementById('btn-promise-any').addEventListener('click', function() {
            const resultDiv = document.getElementById('demo2-result');
            resultDiv.innerHTML = 'Running Promise.any...';
            
            const promises = [
                createPromise(1, 3000, true),
                createPromise(2, 1000, false),
                createPromise(3, 2000, true)
            ];
            
            // Check if Promise.any is supported
            if (typeof Promise.any === 'function') {
                Promise.any(promises)
                    .then(result => {
                        resultDiv.innerHTML = `
                            <h4>Promise.any Result:</h4>
                            <p>${result}</p>
                            <p>Promise.any returns the first promise that fulfills (resolves). If all promises reject, it throws an AggregateError.</p>
                        `;
                    })
                    .catch(error => {
                        resultDiv.innerHTML = `
                            <h4>Promise.any Error:</h4>
                            <p>All promises rejected</p>
                            <pre>${error.message}</pre>
                        `;
                    });
            } else {
                resultDiv.innerHTML = `
                    <h4>Promise.any Not Supported</h4>
                    <p>Your browser does not support Promise.any. This method is relatively new and may not be available in all browsers.</p>
                `;
            }
        });

        // Helper function to update progress bar for Example 3
        function updateProgress(percent) {
            const progressBar = document.getElementById('fetch-progress');
            progressBar.style.width = `${percent}%`;
        }

        // Fetch users
        async function fetchUsers() {
            const resultDiv = document.getElementById('demo3-result');
            resultDiv.innerHTML = 'Fetching users...';
            updateProgress(20);
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/users');
                updateProgress(60);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                const users = await response.json();
                updateProgress(100);
                
                return users;
            } catch (error) {
                updateProgress(100);
                throw error;
            }
        }

        // Fetch posts
        async function fetchPosts() {
            const resultDiv = document.getElementById('demo3-result');
            resultDiv.innerHTML = 'Fetching posts...';
            updateProgress(20);
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts');
                updateProgress(60);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                const posts = await response.json();
                updateProgress(100);
                
                return posts;
            } catch (error) {
                updateProgress(100);
                throw error;
            }
        }

        // Event handlers for buttons in Example 3
        document.getElementById('btn-fetch-users').addEventListener('click', async function() {
            const resultDiv = document.getElementById('demo3-result');
            updateProgress(0);
            
            try {
                const users = await fetchUsers();
                
                resultDiv.innerHTML = `
                    <h4>Users:</h4>
                    <p>Fetched ${users.length} users</p>
                    <pre>${JSON.stringify(users.slice(0, 3), null, 2)}...</pre>
                `;
            } catch (error) {
                resultDiv.innerHTML = `
                    <h4>Error:</h4>
                    <p>${error.message}</p>
                `;
            }
        });

        document.getElementById('btn-fetch-posts').addEventListener('click', async function() {
            const resultDiv = document.getElementById('demo3-result');
            updateProgress(0);
            
            try {
                const posts = await fetchPosts();
                
                resultDiv.innerHTML = `
                    <h4>Posts:</h4>
                    <p>Fetched ${posts.length} posts</p>
                    <pre>${JSON.stringify(posts.slice(0, 3), null, 2)}...</pre>
                `;
            } catch (error) {
                resultDiv.innerHTML = `
                    <h4>Error:</h4>
                    <p>${error.message}</p>
                `;
            }
        });

        document.getElementById('btn-fetch-both').addEventListener('click', async function() {
            const resultDiv = document.getElementById('demo3-result');
            resultDiv.innerHTML = 'Fetching users and posts in parallel...';
            updateProgress(0);
            
            try {
                // Start both fetch operations in parallel
                const usersPromise = fetch('https://jsonplaceholder.typicode.com/users');
                const postsPromise = fetch('https://jsonplaceholder.typicode.com/posts');
                
                updateProgress(30);
                
                // Wait for both to complete
                const [usersResponse, postsResponse] = await Promise.all([usersPromise, postsPromise]);
                
                updateProgress(60);
                
                // Check if responses are ok
                if (!usersResponse.ok || !postsResponse.ok) {
                    throw new Error('One or more requests failed');
                }
                
                // Parse JSON from both responses
                const users = await usersResponse.json();
                const posts = await postsResponse.json();
                
                updateProgress(100);
                
                resultDiv.innerHTML = `
                    <h4>Parallel Fetch Results:</h4>
                    <p>Fetched ${users.length} users and ${posts.length} posts</p>
                    <h5>Users (first 2):</h5>
                    <pre>${JSON.stringify(users.slice(0, 2), null, 2)}</pre>
                    <h5>Posts (first 2):</h5>
                    <pre>${JSON.stringify(posts.slice(0, 2), null, 2)}</pre>
                    <p>Using Promise.all allows multiple fetch operations to run in parallel, saving time.</p>
                `;
            } catch (error) {
                updateProgress(100);
                resultDiv.innerHTML = `
                    <h4>Error:</h4>
                    <p>${error.message}</p>
                `;
            }
        });

        // Initialize
        updateProgress(0);
    </script>
</body>
</html>